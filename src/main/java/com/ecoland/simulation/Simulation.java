package com.ecoland.simulation;\n\nimport com.ecoland.common.Constants;\nimport com.ecoland.data.DataLogger; // Import DataLogger\nimport com.ecoland.entity.*;\nimport com.ecoland.model.World;\nimport com.ecoland.model.TerrainType;\n\nimport java.util.List;\nimport java.util.Random;\nimport java.util.concurrent.CopyOnWriteArrayList; // Consider thread safety if needed\nimport java.util.ArrayList;\n\npublic class Simulation {\n\n    private final World world;\n    private final EntityManager entityManager;\n    private final DataLogger dataLogger; // Added DataLogger instance\n    private long currentTick = 0;\n    private final Random random = new Random();\n\n    // Simulation parameters (could be moved to a config object)\n    private int initialHerbivoreCount = 50;\n    private int initialCarnivoreCount = 5;\n    private int initialPlantCount = 100; // Plants represented differently, maybe seed tiles instead?\n\n    public Simulation(int width, int height) {\n        this.world = new World(width, height);\n        this.entityManager = new EntityManager();\n        this.dataLogger = new DataLogger(10); // Log every 10 ticks\n        initializePopulation();\n        this.dataLogger.recordTick(0, this.entityManager); // Log initial state at tick 0\n    }\n\n    // Constructor using default world size\n    public Simulation() {\n        this(Constants.DEFAULT_WORLD_WIDTH, Constants.DEFAULT_WORLD_HEIGHT);\n    }\n\n    private void initializePopulation() {\n        System.out.println(\"Initializing population...\");\n        // Add Herbivores\n        for (int i = 0; i < initialHerbivoreCount; i++) {\n            spawnEntity(SpeciesType.HERBIVORE);\n        }\n        // Add Carnivores\n        for (int i = 0; i < initialCarnivoreCount; i++) {\n            spawnEntity(SpeciesType.CARNIVORE);\n        }\n\n        // Add initial Plants (or ensure generator creates enough initial food)\n        // For simplicity, let\'s rely on the WorldGenerator\'s initial food placement\n        // and plant growth rather than explicit Plant entities initially.\n        // If explicit Plant entities are desired:\n        /*\n        for (int i = 0; i < initialPlantCount; i++) {\n             spawnEntity(SpeciesType.PLANT);\n        }\n        */\n        entityManager.updateEntityList(); // Process initial additions\n        System.out.println(\"Initial population: \" +\n                           \"Herbivores: \" + entityManager.getPopulationCount(SpeciesType.HERBIVORE) + \", \" +\n                           \"Carnivores: \" + entityManager.getPopulationCount(SpeciesType.CARNIVORE));\n\n    }\n\n    // Helper to spawn an entity at a random valid location\n    private void spawnEntity(SpeciesType type) {\n        int attempts = 0;\n        int maxAttempts = world.getWidth() * world.getHeight(); // Avoid infinite loop\n        while(attempts < maxAttempts) {\n            int x = random.nextInt(world.getWidth());\n            int y = random.nextInt(world.getHeight());\n            if (world.isValidCoordinate(x, y) && world.getTile(x, y).getTerrainType() != TerrainType.WATER && !entityManager.isTileOccupied(x,y) ) {\n                Entity entity = null;\n                switch (type) {\n                    case HERBIVORE:\n                        entity = new Herbivore(x, y);\n                        break;\n                    case CARNIVORE:\n                        entity = new Carnivore(x, y);\n                        break;\n                    case PLANT:\n                        entity = new Plant(x, y); // If using explicit Plant entities\n                        break;\n                }\n                if (entity != null) {\n                    entityManager.addEntity(entity);\n                    return; // Successfully spawned\n                }\n            }\n            attempts++;\n        }\n        System.err.println(\"Warning: Could not find valid spawn location for \" + type);\n    }\n\n    /**\n     * Executes a single step (tick) of the simulation.\n     */\n    public void tick() {\n        currentTick++;\n        // System.out.println(\"--- Tick: \" + currentTick + \" ---\");\n\n        // Get a snapshot of entities for this tick to avoid issues with concurrent modification\n        List<Entity> currentEntities = entityManager.getAllEntities();\n\n        // 1. Update all entities\n        for (Entity entity : currentEntities) {\n            if (entity.isAlive()) {\n                 // Pass the Simulation instance and the World to the update method\n                 entity.update(this, world);\n\n                // Check if entity died during its update\n                if (!entity.isAlive()) {\n                    entityManager.removeEntity(entity);\n                }\n            }\n            else {\n                 // If somehow an entity in the list is already dead, ensure it's marked for removal\n                 entityManager.removeEntity(entity);\n            }\n        }\n\n        // 2. Process births and deaths (add new entities, remove dead ones)\n        entityManager.updateEntityList();\n\n        // 3. Record data for this tick BEFORE world state update (captures end-of-tick populations)\n        dataLogger.recordTick(currentTick, entityManager);\n\n        // 4. Update world state (e.g., plant regrowth on tiles)\n        updateWorldState();\n\n        // Optional: Print stats periodically\n        if (currentTick % 50 == 0) {\n            System.out.println(\"Tick \" + currentTick + \" Pop: \" + entityManager.getTotalPopulation() +\n                               \" (H:\" + entityManager.getPopulationCount(SpeciesType.HERBIVORE) +\n                               \", C:\" + entityManager.getPopulationCount(SpeciesType.CARNIVORE) + \")\");\n        }\n    }\n\n    // Placeholder for world updates independent of entities (e.g., rain, passive plant growth)\n    private void updateWorldState() {\n        // Example: passive plant food regrowth on fertile land tiles\n        double passiveRegrowthRate = 0.01;\n        for (int x = 0; x < world.getWidth(); x++) {\n            for (int y = 0; y < world.getHeight(); y++) {\n                 var tile = world.getTile(x,y);\n                 if(tile.getTerrainType() == TerrainType.GRASS || tile.getTerrainType() == TerrainType.FOREST) {\n                     // Grow based on fertility, but slower than active plants\n                     tile.growPlantFood(tile.getFertility() * passiveRegrowthRate);\n                     // TODO: Add max food cap based on tile type/fertility\n                 }\n            }\n        }\n    }\n\n    /**\n     * Attempts to spawn a new entity near a parent entity.\n     * This is typically called when an entity reproduces.\n     * @param parent The parent entity requesting the spawn.\n     * @param offspringType The type of entity to spawn.\n     * @return The newly spawned entity, or null if spawning failed (no valid location).\n     */\n    public Entity spawnOffspring(Entity parent, SpeciesType offspringType) {\n        if (parent == null || !parent.isAlive()) {\n            return null;\n        }\n\n        int parentX = parent.getX();\n        int parentY = parent.getY();\n\n        // Find valid spawn location (existing logic)\n        List<int[]> possibleLocations = new ArrayList<>();\n        for (int dx = -1; dx <= 1; dx++) {\n            for (int dy = -1; dy <= 1; dy++) {\n                if (dx == 0 && dy == 0) continue;\n                int nx = parentX + dx;\n                int ny = parentY + dy;\n                if (world.isValidCoordinate(nx, ny) &&\n                    world.getTile(nx, ny).getTerrainType() != TerrainType.WATER &&\n                    !entityManager.isTileOccupied(nx, ny)) {\n                    possibleLocations.add(new int[]{nx, ny});\n                }\n            }\n        }\n\n        if (possibleLocations.isEmpty()) {\n            return null; // No suitable location\n        }\n\n        int[] spawnCoords = possibleLocations.get(random.nextInt(possibleLocations.size()));\n        int spawnX = spawnCoords[0];\n        int spawnY = spawnCoords[1];\n\n        // Create offspring genes by copying and mutating parent\'s genes\n        Genes offspringGenes = new Genes(parent.getGenes());\n\n        // Create the offspring entity using the new genes\n        Entity offspring = null;\n        switch (offspringType) {\n            case HERBIVORE:\n                offspring = new Herbivore(spawnX, spawnY, offspringGenes);\n                break;\n            case CARNIVORE:\n                offspring = new Carnivore(spawnX, spawnY, offspringGenes);\n                break;\n            case PLANT:\n                offspring = new Plant(spawnX, spawnY, offspringGenes);\n                break;\n            default:\n                System.err.println(\"Cannot spawn unknown offspring type: \" + offspringType);\n                return null;\n        }\n\n        if (offspring != null) {\n            entityManager.addEntity(offspring);\n            // Optional: Log parent and offspring genes for debugging/observation\n            // System.out.println(String.format(\"Spawned %s at (%d,%d) from parent (%d,%d)\", \n            //      offspringType, spawnX, spawnY, parentX, parentY));\n            // System.out.println(\"  Parent Genes: %s\", parent.getGenes());
            // System.out.println(\"  Offspring Genes: %s\", offspring.getGenes());
            return offspring;\n        }\n        return null;\n    }\n\n    // --- Getters for UI --- //\n\n    public World getWorld() {\n        return world;\n    }\n\n    public EntityManager getEntityManager() {\n        return entityManager;\n    }\n\n    public DataLogger getDataLogger() {\n        return dataLogger;\n    }\n\n    public long getCurrentTick() {\n        return currentTick;\n    }\n\n    // --- Control Methods --- //\n\n    // TODO: Implement methods for pause, resume, speed change, user interaction (spawn, place food)\n    // These will likely interact with a timer/loop in the main application thread.\n\n} 