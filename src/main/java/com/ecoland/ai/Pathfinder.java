package com.ecoland.ai;\n\nimport com.ecoland.model.TerrainType;\nimport com.ecoland.model.World;\nimport com.ecoland.entity.Entity; // Needed for movement cost checks potentially\n\nimport java.util.*;\n\n/**\n * Implements the A* pathfinding algorithm for entities to navigate the world.\n */\npublic class Pathfinder {\n\n    private static final int MAX_SEARCH_NODES = 1000; // Limit search space to prevent performance issues\n\n    // Node class for A* search\n    private static class Node implements Comparable<Node> {\n        int x, y;\n        double gCost; // Cost from start to this node\n        double hCost; // Heuristic cost from this node to target\n        double fCost; // gCost + hCost\n        Node parent;\n\n        Node(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public int compareTo(Node other) {\n            return Double.compare(this.fCost, other.fCost);\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Node node = (Node) o;\n            return x == node.x && y == node.y;\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(x, y);\n        }\n    }\n\n    /**\n     * Finds a path from start coordinates to end coordinates using A*.\n     *\n     * @param world The world grid.\n     * @param startX Start x coordinate.\n     * @param startY Start y coordinate.\n     * @param endX Target x coordinate.\n     * @param endY Target y coordinate.\n     * @param entity The entity requesting the path (used for movement cost/passability rules).\n     * @return A List of coordinate pairs [x, y] representing the path (excluding start, including end), or null if no path is found.\n     */\n    public List<int[]> findPath(World world, int startX, int startY, int endX, int endY, Entity entity) {\n        Node startNode = new Node(startX, startY);\n        Node endNode = new Node(endX, endY);\n\n        PriorityQueue<Node> openList = new PriorityQueue<>();\n        HashSet<Node> closedList = new HashSet<>();\n\n        startNode.gCost = 0;\n        startNode.hCost = heuristic(startNode, endNode);\n        startNode.fCost = startNode.hCost;\n        openList.add(startNode);\n\n        int nodesSearched = 0;\n\n        while (!openList.isEmpty() && nodesSearched < MAX_SEARCH_NODES) {\n            Node currentNode = openList.poll();\n            nodesSearched++;\n\n            if (currentNode.equals(endNode)) {\n                return reconstructPath(currentNode);\n            }\n\n            closedList.add(currentNode);\n\n            // Explore neighbors (8 directions)\n            for (int dx = -1; dx <= 1; dx++) {\n                for (int dy = -1; dy <= 1; dy++) {\n                    if (dx == 0 && dy == 0) continue;\n\n                    int neighborX = currentNode.x + dx;\n                    int neighborY = currentNode.y + dy;\n\n                    // Check if neighbor is valid\n                    if (!world.isValidCoordinate(neighborX, neighborY)) {\n                        continue;\n                    }\n\n                    Node neighborNode = new Node(neighborX, neighborY);\n\n                    // Check if neighbor is in closed list\n                    if (closedList.contains(neighborNode)) {\n                        continue;\n                    }\n\n                    // Check passability based on entity type\n                    if (!isPassable(world, neighborX, neighborY, entity)) {\n                        closedList.add(neighborNode); // Treat impassable as closed\n                        continue;\n                    }\n\n                    // Calculate cost to reach neighbor\n                    double moveCost = getMovementCost(world, currentNode, neighborNode, entity);\n                    double newGCost = currentNode.gCost + moveCost;\n\n                    boolean isInOpenList = openList.contains(neighborNode);\n\n                    if (!isInOpenList || newGCost < neighborNode.gCost) {\n                        neighborNode.gCost = newGCost;\n                        neighborNode.hCost = heuristic(neighborNode, endNode);\n                        neighborNode.fCost = neighborNode.gCost + neighborNode.hCost;\n                        neighborNode.parent = currentNode;\n\n                        if (!isInOpenList) {\n                            openList.add(neighborNode);\n                        } else {\n                            // Update the node in the priority queue (requires remove & add)\n                            openList.remove(neighborNode);\n                            openList.add(neighborNode);\n                        }\n                    }\n                }\n            }\n        }\n\n        System.out.println(\"A* pathfinding failed or exceeded node limit from (\"+startX+\",\"+startY+\") to (\"+endX+\",\"+endY+\")\");\n        return null; // No path found\n    }\n\n    // Heuristic function (Manhattan distance - cheaper than Euclidean)\n    private double heuristic(Node a, Node b) {\n        return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\n    }\n\n    // Reconstruct path from end node back to start node\n    private List<int[]> reconstructPath(Node endNode) {\n        LinkedList<int[]> path = new LinkedList<>();\n        Node current = endNode;\n        while (current.parent != null) {\n            path.addFirst(new int[]{current.x, current.y});\n            current = current.parent;\n        }\n        return path;\n    }\n\n    // Check if a tile is passable for a given entity\n    private boolean isPassable(World world, int x, int y, Entity entity) {\n        var tile = world.getTile(x, y);\n        if (tile == null) return false;\n\n        // Basic rule: No movement into water (can be refined per species)\n        if (tile.getTerrainType() == TerrainType.WATER) {\n            // Allow specific species through water later if needed\n            return false;\n        }\n\n        // Add other checks: e.g., very steep hills might be impassable\n        if (tile.getTerrainType() == TerrainType.HILL && tile.getElevation() > 0.9) { // Example: Very steep hills\n             // return false; // Might depend on entity speed/genes?
        }\n\n        // TODO: Check for occupation? A* usually assumes static obstacles.\n        // If dynamic entities block paths, might need replanning.\n\n        return true;\n    }\n\n    // Get movement cost between adjacent nodes\n    private double getMovementCost(World world, Node from, Node to, Entity entity) {\n        double cost = 1.0; // Base cost for adjacent tiles\n\n        // Diagonal movement costs more (sqrt(2) ~= 1.414)\n        if (from.x != to.x && from.y != to.y) {\n            cost *= 1.414;\n        }\n\n        // Terrain cost modifier (example: hills are harder to traverse)\n        var toTile = world.getTile(to.x, to.y); // Use the passed world object\n        if (toTile != null) {\n            switch (toTile.getTerrainType()) {\n                case HILL:\n                    cost *= 1.5; // Hills take 50% more effort\n                    break;\n                case FOREST:\n                    cost *= 1.2; // Forests slightly more effort\n                    break;\n                case DESERT:\n                    cost *= 1.1; // Deserts slightly more effort\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        // Could also incorporate entity speed (inverse relationship? slower = higher cost per step?)\n        // cost /= entity.getSpeed(); // This might need balancing\n\n        return cost;\n    }\n\n} 